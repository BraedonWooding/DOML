# Data Oriented Markup Language - DOML (.Net)
> By Braedon Wooding

> Latest Version N/A

> *Note: This spec is changing a whole lot!  Until its marked at-least 1.0 you should regard it as unstable*

This is the Specification document for DOML (Data Oriented Markup Language), which is a 'new' markup language that takes a different approach then most. It enacts to simulate a call-stack rather than simulate data structures, this allows it to represent a constructor like look rather than the usual {...} mess.  Its simplicity can't be ignored, the entire ABNF is 80 lines including comments and nice indentation which is insanely small (especially considering TOML another 'minimalistic language' has a 219 line grammar which around ~2.74x larger)!

## Why DOML?
DOML was born out of a need, a need to have a markup language that stops functioning like just a text file and starts functioning like an integral part of the program, it was born out of an annoyance at writing code of loading a file in and either having to manually de-serialize/serialize or having to fiddle with an automatic serializer, and never knowing if the solution had a small typo in it.  I finally 'cracked' and brought out the playground project and whiteboard when I saw someone building an entire application whose whole purpose was to just take data and build a JSON object, since it was easier then writing 50 billion `"` and braces, and was validated (unlike every other markup language on the planet).  So I sat down at my desk and crafted DOML, a solution which I aimed to be efficient and to be practical to allow you to do whatever you need without much intrusion.  Hopefully I'm correct.  Further more DOML is simple, the first parser was < 300 lines, and today its < 2000 (due to the addition of bytecode and security), the entire ABNF fits in 80 lines and there are only TWO main rules (excluding comments) that is `creation` or `set` which either perform a constructor or set a variable within a variable created in a creation call.  It has 0 keywords and only 5 operators (`...`, `=`, `,`, `@`, `;`)!  Operators like `.` are part of the name, and other operators like `(`, `)`, `{`, `[`... (effectively any open/close brace/bracket/arrow/...) are replaced with `.` so the following are all the SAME call (simplicity mhmmmm); `.RGB(Normalised)`, `.RGB[Normalised]`, `.RGB<Normalised>` are all just `.RGB.Normalised`!

## Objectives
Efficient data serialization.  Not only be fast, but also the avoidance of wasting memory.  Removal of the separation between markup languages and your project, the burning of the obscure and ugly bridge to join the two islands together using a nice steel well constructed bridge that is easy to traverse and actually supports vehicles (maybe I went too far on this analogy?)...  Further more it aims to be simple, the avoidance of 'arrays' and complex structures for implicit collections is key!

## A quick overview
```C
// This is a comment
@ Test        = System.Color ... // System is just a random name represents a 'root object', System.Color represents a 'object'
;             .RGB             = 255, 64, 128

@ TheSame     = System.Color ...
;             .RGB(Normalised) = 1, 0.25, 0.5 // 'ish' normally I would round down not up but eh

@ AgainSame   = System.Color ...
;             .RGB(Hex)        = 0xFF4080
;             .Name            = "OtherName

/* Multi Line Comment Blocks are great
  // Note: nesting is allowed its just till I make a github syntax and it gets accepted I won't include it in examples, since I'll use the C one in the meantime and that doesn't allow nesting multi line comment blocks
  Anyways lets go and copy another previous one by just copying over the values.
*/
@ Copy        = System.Color ...
;             .RGB             = Test.RGB
;             .Name            = "Copy"
```

Below is the IR representation of the above code;
```assembly
; This is an autogenerated IR representation of the supplied source code
;           This is a comment             ; USER COMMENT
; Setup Space
makespace   4                             ; Makes sure the stack supports 4 objects at a time
checkspace  System.Color::RGB             ; It calls a sizeof function and makes sure that the size will fit
makereg     4                             ; Makes sure threre are 4 registers
; Test.RGB
new         System.Color                  ; Creates a new object from System.Color
regobj      0                             ; Registers top object to register 0
push32i     255                           ; Pushes 32
push32i     64                            ; Pushes 64
push32i     128                           ; Pushes 128
pushobj     0                             ; Pushes object from register 0
set         System.Color::RGB             ; Call RGB on System.Color
; Check if room for next parameters
compsize    0                             ; If the current size is <= 0 push true else false
panic       false                         ; Panic if top is false
; TheSame.RGB.Normalised
new         System.Color                  ; Creates a new object from System.Color
regobj      1                             ; Registers top object to register 1
push32f     1                             ; Pushes 1.0f
push32f     0.25                          ; Pushes 0.25f
push32f     0.5                           ; Pushes 0.5f
pushobj     1                             ; Pushes object from register 1
set         System.Color::RGB.Normalised  ; Call RGB.Normalised on System.Color
; Check if room for next parameters
compsize    2                             ; If the current size is <= 2 push true else false
panic       false                         ; Panic if top is false
; AgainSame.RGB.Hex
new         System.Color                  ; Creates a new object from System.Color
regobj      2                             ; Registers top object to register 2
push32i     16728192                      ; Pushes 16728192
pushobj     2                             ; Pushes object from register 2
set         System.Color::RGB.Hex         ; Call RGB.Hex on System.Color
; Check if room for next parameters
compsize    2                             ; If the current size is <= 2 push true else false
panic       false                         ; Panic if top is false
; AgainSame.Name
pushstr     "OtherName"                   ; Pushes "OtherName"
pushobj     2                             ; Pushes object from register 2
set         System.Color::Name            ; Call Name on System.Color
; Check if room for next parameters
compsize    0                             ; If the current size is <= 0 push true else false
panic       false                         ; Panic if top is false
; Copy.RGB
new         System.Color                  ; Creates a new object from System.Color
regobj      3                             ; Registers top object to register 3
pushobj     0                             ; Pushes object from register 0
call        System.Color::RGB             ; Gets RGB of System.Color
pushobj     3                             ; Pushes object from register 3
set         System.Color::RGB             ; Sets RGB of System.Color
; Check if room for next parameters
compsize    2                             ; If the current size is <= 2 push true else false
panic       false                         ; Panic if top is false
; Copy.Name
pushstr     "Copy"                        ; Pushes "Copy"
pushobj     3                             ; Pushes object from register 2
set         System.Color::Name            ; Call Name on System.Color
; Cleanup
cleanup     true                          ; Cleanup and quit
```
The use of `;` as a comment is purely just due to its comparison to assembly, I haven't actually decided on whether or not comments will 1) be allowed and 2) have the character `;` or `//` or even `#` though there will be no block comments and as you can see above the block comment is converted into a list of comments.  Comments will be reserved as you can see if they are allowed and extra ones can be toggled to display exactly what is occuring (incase one has to debug).

Effectively the 'compiler' will convert your DOML markup to this set of commands which will be executed by the system.  Note: this is done because the actual conversion to bytecode is effectively nothing in terms of speed and the output won't be emitted unless that is wanted by the user.  This also allows the actual runner to run the bytecode rather than interpret the markup allowing it to execute faster.  Sending bytecode over the internet rather than a JSON output is also faster and more compact.

Another thing to note is that while in the bytecode I used things like `System.Color`, `RGB`, `RGB.Normalised` and so on in the actual implementation it will use an index value like `#0`/`0`/`*0` the exact prefix (if any) will be determined later, and it'll map to the implementation.

## Quick Spec Details
- DOML is case sensitive
- DOML must be a valid UTF-8 encoded unicode document (though I don't see why you can't support other formats)
- DOML refers to the initial source code not to the produced bytecode, parsers need to support ONLY DOML and don't need to support parsing bytecode, though due to its simplicity it may be easy to support.

## Types
This will be covered in more detail elsewhere but here are all the types

| Type          | Example Values                        | Details (all suffixes are case insensitive)        |
| ------------- | ------------------------------------- | -------------------------------------------------- |
| Integer       | 12, -40, +2, 40L, 40s, 01010b, 0x40FF | Add s/l for short/long  b for binary, 0x for hex   |
| Unsigned      | 40u, -40uL, 80Su                      | Add u for unsigned                                 |
| Float         | 10.0009, -0.05f, 5e+22, 1e6, -2.54E-2 | E/optional f for exponent/float (needs format)     |
| Double        | 10.5d, 20D, 5e+22d, 1e6d, -2.54E-2d   | E/required d for exponent/double (needs format)    |
| String        | "This contains a \" escaped quote"    | "...", you can escape `"` with `\`                 |
| Char          | 'C', '5'                              | Maps to a character (Ambigious needs format        |
| Boolean       | true, false                           | The boolean values                                 |
| Object        | Test, X, MyColor                      | Refers to a previously defined object              |

## Syntax
I'll cover this quickly here you can view an indepth either under [indepth syntax](syntax.md) or at by viewing the [abnf](doml.abnf).

#### Comments
C-Styled comments either `//` or `/*` nesting is allowed for both;
```
// This is a comment
/* This is a block and /* this is a nested block */ */
```

#### Structure
The structure is simple you have two types of 'calls' you have either 'creation calls' or 'set calls' they look like either;
```C
// Create X
@ X   = Y.Z
;    X.A = B, C, D
```
Where `B`, `C`, `D` can be anything from the above type table, they can also refer to a 'getter' like `System.Version`.

You can shorten the structure a little using the `...` operator such as;
```C
@ X   = Y.Z ...
;     .A = B, C, D
```
Note that the second X wasn't required, this is because the `...` means just presume that every thing that starts with `.` is referring to `X` UNTIL you meet another `@` (regardless if that `@` has a `...`) you can always just refer to other objects like;
```C
@ B   = W.V
@ X   = Y.Z ...
;     .A = B, C, D
;    B.E = F, G, H
```

#### That's it!
> Wait what?
Yes it may seem weird but the syntax is THAT simple!  It will probably expand a little but I want to refrain from heavy changes that break a lot of things.

#### But no arrays...?
There are still arrays remember `B, C, D` you passing multiple values to `.A` your effectively passing a heterogeneous array (allows any type), at its core arrays are just this (well that and they are homogeneous or the same type) modern arrays often tack on a little length variable and I guess you could always do that yourself, and the argument may be that we should handle that, but I'm still not convinced on that front since the ONLY case where that would be useful would be when you are passing multiple values to a function and you want one of the values to be an array and the others to not be an array.  Otherwise you can always just either keep popping till you get a 'false' (run out of elements) or be a good person and do a for loop using a variable that says how big the 'stack' is.

Note: this is where I should say that all the DOML implementations by me will have the same API (with only minor differences) and I suggest if other people make new implementations they follow the same API guidelines, though I'm not going to enforce that so the whole array thing is more of a parser implemented thing then anything.

## Comparison with other formats
Firstly I'll list the problems with other formats; XML has always been hard to read, hard to write (though I would claim its still easier to write then JSON by quite a landslide) and especially hard to parse and its spec is a complete mess.  JSON is easy to parse, but still suffers from being annoyingly verbose.  YAML is much improved in this manner, but however due to its tight bindings to JSON (all JSON works in YAML parsers) it stretches out its SPEC even further (and YAML's spec is sooo large that no parser is capable of supporting it all), and even further more its reliance on JSON hinders whitespace meaning that if you choose indentation you need to like Python keep everything indented right which means that its not compact enough for web use (and JSON isn't either though its often used due to its native compatibility with Javascript).

A few others;
- INI is old, and suffers from a lot (though I quite like it for its simplicity)

So what one is like DOML the most?  Well I guess I would say TOML?  TOML is a great step forward in the advancement of markup languages though I still feel it suffers from trying to create a new thing from what already is here rather than create a new thing from the core fundamentals of what it should be (which DOML was created out of), this is why I can't really compare it greatly with other formats...  Because it was built to be a different sort of tool, a different sort of markup language it accomplishes the same goal but in a way that I would *claim* has never been done before (succesfully at least).  This isn't just another markup language (damn should have included a YAML pun), but rather I'm sure some will claim isn't really even a 'markup language', and shares more similiarity with scripting languages then actual markup languages.

Though I would claim differently, the clear difference between a scripting language and a programming language is *how* you use it and in what context, and I would further claim that the biggest difference between a markup language and a scripting language is how you *can* you use (or rather *should*), since while DOML is 'turing complete' (though you would have to add functions like math and basic drawing for anyone to be like 'yeh now its turing complete') it purposefully limits actions like math and so on, since its built to represent data thus its a data oriented language.  Every action you perform is around the manipulation of data (again the clear distinction is that the 'purpose' of the language is to create data the purpose of other languages is to creation applications and while both may 'manipulate data' its clear to see what is different).

So to 'wrap up', DOML is more than just a simplistic alternative, its a 'scripting language' with the whole goal of creating data, not with using it!  Thus I would claim its a markup-language due to the similar goals and the restrictions placed on it, though I'm sure others will disagree.

## Get Involved!
Anyways, if you have any new changes you may wish to add please ask in the issues!  I will be more cautious to accept PRs if the changes aren't talked about in an issue (though the obvious exception is if you are fixing up typos/errors or if its a super small thing, OR if you are adding your implementation / project to the list all these don't require issues of course).  Further more I'll open up a discord chat somewhat soon (and maybe a mailing list, though nowadays they seem a little archaic).

## Projects using DOML
- None yet, if you know of one please send a PR adding to this list!

## Implementations of DOML
If you have an implementation, send a pull request adding to this list. Please note the version tag that your parser supports in your Readme.

## v0.1 Compatible

## In Progress
- [.Net (C#/F#/...)](https://github.com/DOML-DataOrientedMarkupLanguage/DOML.net)
- [C++](https://github.com/DOML-DataOrientedMarkupLanguage/DOML-Cxx)

## Editor Support
- None yet, but VIM/Notepad++/EMACS/Sublime Text/VS Code are all in development
